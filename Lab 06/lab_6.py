# -*- coding: utf-8 -*-
"""Lab 6

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wzbggg4umvbt1dTqz8qsj7G7NGjhK78B

# Imports
"""

import numpy as np
import cmath
import time 
import sounddevice as sd
from scipy.io.wavfile import write

class dft():
  def __init__(self, x, fs, K=None):
    if (type(fs) != int) or (fs<=0):
      raise NameError('The frequency fs should be a positive integer.')
    if not isinstance(x, np. ndarray):
      raise NameError('The input signal x must be a numpy array.')
    if isinstance(x, np. ndarray):
      if x.ndim!=1:
        raise NameError('The input signal x must be a numpy vector array.')
    self.x=x
    self.fs=fs
    self.N=len(x)
    if K == None:
      K = len(self.x)

    if (type(K) != int) or (K <= 0) or (K < 0):
      raise NameError('K should be a positive integer.')
    self.K=K
    self.f=np.arange(self.K)*self.fs/self.K
    self.f_c=np.arange(-np.ceil(K/2)+1,np.floor(self.K/2)+1)*self.fs/self.K
  
  def changeK(self,K):
    if (type(K) != int) or (K <= 0) or (K <  0):
      raise NameError('K should be a positive integer.')
    old_K=self.K
    self.K=K
    self.f=np.arange(self.K)*self.fs/self.K
    self.f_c=np.arange(-np.ceil(K/2)+1,np.floor(self.K/2)+1)*self.fs/self.K
    print('The value of K was succefully change from %d to %d'%(old_K,self.K))
    pass

  def solve3(self):
      X=np.fft.fft(self.x,self.K)/np.sqrt(self.N);
      X_c=np.roll(X,np.int(np.ceil(self.K/2-1)))
      return [self.f,X,self.f_c,X_c]
  

class recordsound():
  def __init__(self, T, fs):
    self.T = T
    self.fs = fs
    
  def solve(self):
    print('start recording \n')
    voicerecording = sd.rec(int(self.T * self.fs), self.fs, 1)
    sd.wait()
    print('end recording \n')
    write('myvoice1.wav', self.fs, voicerecording.astype(np.float32))
    
    return voicerecording

def print_matrix(A, nr_decimals = 2):
  nr_digits = np.maximum(np.floor(np.log10(np.amax(np.abs(A)))),0) + 1
  nr_digits = nr_digits + nr_decimals + 3
  nr_digits = "{0:1.0f}".format(nr_digits)
  number_format = "{0: " + nr_digits + "." + str(nr_decimals) + "f}"
  
  n = len(A)
  m = len(A[0])
  for l in range(m):
    value = " "
    for k in range(n):
      value = value + " " + number_format.format(A[k,l])
    print(value)

"""# Section 1

"""

# Create training sets

def training_raw_digits(digit_recs, digits, T, fs, number_of_recordings):
  for digit in digits:
    individual_recordings = np.zeros((number_of_recordings, int(T*fs)))
    print('Say ' + str(digit) + ' when prompted')
    for i in range (number_of_recordings):
      time.sleep(1)
      record_digit = recordsound(T, fs)
      voice = record_digit.solve().reshape(int(T*fs))
      individual_recordings[i, :] = voice
    digit_recs.append(individual_recordings)

  np.save("recording_digits.npy", digit_recs)

def training_dft_digits(voice_recording_name, digits, fs):
  recordings = np.load(voice_recording_name)
  number_digits = len(recordings)
  number_recordings, N = recordings[0].shape
  DFTs = []
  DFTs_c = []
  for individual_digit in recordings:
    DFT_a = np.zeros((number_recordings, N))
    DFT_a_c = np.zeros((number_recordings, N))
    for i in range(number_recordings):
      selected_rec = individual_digit[i, :]
      normalization_i = np.linalg.norm(selected_rec)
      selected_rec = selected_rec / normalization_i
      DFT_selected_rec = dft(selected_rec, fs)
      [_, X, _, X_c] = DFT_selected_rec.solve3()
      DFT_a[i, :] = X
      DFT_a_c[i, :] = X_c
    DFTs.append(DFT_a)
    DFTs_c.append(DFT_a_c)
  np.save("spoken_digits_DFTs.npy", DFTs)
  np.save("spoken_digits_DFTs_c.npy", DFTs_c)


def test_digits(digit_recs, digits, T, fs, number_of_recordings):
    individual_recordings = np.zeros((number_of_recordings, int(T*fs)))
    print('Say a randomly chosen 1 or 2 when prompted')
    for i in range(number_of_recordings):
      time.sleep(1) 
      record_digit = recordsound(T, fs) 
      record_digit = recordsound(T, fs)
      voice = record_digit.solve().reshape(int(T*fs))
      individual_recordings[i, :] = voice
    digit_recs.append(individual_recordings)
    np.save("test_set.npy", individual_recordings) 

    test_set_audio = individual_recordings.reshape(T*fs*number_of_recordings)
    file_name = 'test_set_audio_rec.wav'
    write(file_name, fs, test_set_audio.astype(np.float32))



if __name__ == '__main__':
  T = 1
  fs = 8000
  N = 10
  digits = [1,2]
  digit_recs = []

  training_raw_digits(digit_recs, digits, T, fs, N)
  training_dft_digits("recording_digits.npy", digits, fs)
  test_digits(digit_recs, digits, T, fs, N)

"""# Section 2"""

if __name__ == '__main__':
  T = 1
  fs = 8000
  
  test_set = np.load("test_set_DFTs.npy")
  training_set_DFTs = np.abs(np.load("spoken_digits_DFTs.npy"))
  
  num_digits = len(training_set_DFTs)
  _, N = training_set_DFTs[0].shape
  average_spectra = np.zeros((num_digits, N), dtype=np.complex_)

  for i in range(num_digits):
    average_spectra[i, :] = np.mean(training_set_DFTs[i], axis=0) 

  num_recs, N = test_set.shape
  predicted_labels = np.zeros(num_recs)
  
  DFTs_aux = np.zeros((num_recs, N), dtype=np.complex_)
  DFTs_c_aux = np.zeros((num_recs, N), dtype=np.complex_)
  
  for i in range(num_recs):
    rec_i = test_set[i, :]
    energy_rec_i = np.linalg.norm(rec_i)
    rec_i /= energy_rec_i
    DFT_rec_i = dft(rec_i, fs)
    [_, X, _, X_c] = DFT_rec_i.solve3()
    DFTs_aux[i, :] = X 
    DFTs_c_aux[i, :] = X_c
    
    inner_prods = np.zeros(num_digits) 
    for j in range(num_digits):
      inner_prods[j] = np.inner(np.abs(X), np.abs(average_spectra[j, :]))
    predicted_labels[i] = np.argmax(inner_prods) + 1
  
  print("Average spectrum comparison --- predicted labels: \n")
  print_matrix(predicted_labels[:, None], nr_decimals=0)
  
  np.save("test_set_DFTs.npy", DFTs_aux)
  np.save("predicted_labels_avg.npy", predicted_labels)

"""# Section 3 """

if __name__ == '__main__':
  T = 1
  fs = 8000

  test_set = np.load("test_set_DFTs.npy")
  training_DFTs = np.abs(np.load("spoken_digits_DFTs.npy"))

  num_signals = len(training_DFTs)
  _, N = training_DFTs[0].shape         #rows, columns

  #Normalize DFTs of test set
  DFTs_a = np.zeros((num_recs, N), dtype=np.complex_)
  DFTs_a_c = np.zeros((num_recs, N), dtype=np.complex_)
  training_size, _ = training_DFTs[0].shape

  predicted = np.zeros(num_recs)
  for i in range(num_signals): 
    current = test_set[i, :]
    normalization_i = np.linalg.norm(current)
    current = current / normalization_i
    DFT_current = dft(current, fs)
    [_, X, _, X_c] = DFT_current.solve3()
    DFTs_a[i, :] = X
    DFTs_a_c[i, :] = X_c

    inner_product1 = np.zeros((num_signals, ))
    inner_product2 = np.zeros((num_signals, ))
    inner1_max = -1000
    inner2_max = -1000 
    for k in range(num_signals):
        current_dft = training_DFTs[j,k]
        inner_product1[j, k] = np.inner(np.abs(X), (current_dft))
        inner_product2[j, k] = np.inner(np.abs(X_c), (current_dft))
        if inner_product1 > inner1_max:
          inner1_max = inner_product1 
        if inner_product2 > inner2_max:
          inner2_max = inner_product2
    if inner1_max > inner2_max:
      predicted[i] = 1
    else: 
      predicted[i] = 2

print("Nearest neighbor comparison --- predicted labels: /n")
print_matrix(predicted[:, None], nr_decimals = 0)
np.save("test_set_DFTs.npy", DFTs_a)
np.save("tes_set_DFTs_c.npy", DFTs_a_c)