# -*- coding: utf-8 -*-
"""Lab 10

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fbNpNOOfgslTuXXvGRUjHDs6FHu_H9AH

# Imports
"""

import numpy as np
import cmath
import matplotlib.pyplot as plt
import matplotlib.image as mpimg 
from scipy.fft import dct, idct
import scipy.sparse.linalg
import numpy as np
import pickle as pkl
from PIL import Image as im

"""# Data Imports"""

# %%capture
!pip install -U gdown scipy
!gdown 1mTtEMU0QhCBucJPQsveBnZzf_e_03DTj
!unzip -o lab10data.zip

"""# Section 1.1"""

class K_eigenvectors():
  def __init__(self, X, K):
    self.X = X
    self.K = K
  
  def solve(self):
    L, V = scipy.sparse.linalg.eigs(self.X, k=self.K)
    return V[:, 0:self.K]

dictionary = pkl.load(open('lab10data/lab10data.pkl', 'rb'))
faces = dictionary['faces']
mu = dictionary['mu']
sigma = dictionary['sigma']

K = 20

eig_obj = K_eigenvectors(sigma, K)
K_eig = eig_obj.solve()
print('Unitary Check: ', np.allclose(np.eye(K), np.matmul(np.conj(np.transpose(K_eig)), K_eig)))

"""# Section 1.2"""

# roll eigenvectors back into 2D array (image) 

class EigenfaceDecomposition(): 
  def __init__(self, face, mu, eigenfaces):
    self.x = np.ravel(face, 'F')   # return 1D array (eigenface)
    self.mu = np.ravel(mu, 'F')    # mean face
    self.V = eigenfaces

  def solve(self):
    return np.matmul(np.conj(np.transpose(self.V)), self.x-self.mu)

# test EigenfaceDecomposition
face_idx = 20

eigendec_obj = EigenfaceDecomposition(faces[:,:,face_idx], mu, K_eig)
coefficients = eigendec_obj.solve()
print('The coefficients of the ', K, ' principal components are:', coefficients)

"""# Section 2.1"""

class Reconstruction():
  def __init__(self, mu, eigens, coeff):
    self.mu = np.ravel(mu, 'F')
    self.K = eigens.shape[1]
    self.V = eigens
    self.w = coeff
  
  def solve(self):
    return np.transpose((np.abs(np.matmul(self.V,self.w) + self.mu)).reshape((92, 112)))

Ks = [20, 5, 25, 50]

for K in Ks:
  eig_obj = K_eigenvectors(sigma, K)
  K_eig = eig_obj.solve()
  print('Unitary Check: ', np.allclose(np.eye(K), np.matmul(np.conj(np.transpose(K_eig)), K_eig)))

  og_face = faces[:,:,face_idx]

  eigendec_obj = EigenfaceDecomposition(og_face, mu, K_eig)
  coefficients = eigendec_obj.solve()
  # print('The coefficients of the ', K, ' principal components are:', coefficients)

  recon_obj = Reconstruction(mu, K_eig, coefficients)
  recon_face = recon_obj.solve()

  image = im.fromarray(og_face.astype(np.uint8), mode='L')
  display(image)
  # image.show()
  # image.save("original.png")

  recon_image = im.fromarray(recon_face.astype(np.uint8), mode='L')
  display(recon_image)
  # recon_image.show()
  # recon_image.save("recon.png")

"""# Section 2.2"""

Ks_list = list(range(1, 20))
Ks = [] 

for K in Ks_list:
  eig_obj = K_eigenvectors(sigma, K)
  K_eig = eig_obj.solve()

  og_face = faces[:,:,face_idx]

  eigendec_obj = EigenfaceDecomposition(og_face, mu, K_eig)
  coefficients = eigendec_obj.solve()

  recon_obj = Reconstruction(mu, K_eig, coefficients)
  recon_face = recon_obj.solve()
  energy_error_norm = np.linalg.norm(og_face - recon_face)
  energy_of_error = (energy_error_norm)**2 
  K0_norm = np.linalg.norm(og_face - mu)
  K0_error =  (K0_norm)**2
  error_reduction = ((K0_error-energy_of_error)/K0_error)
  Ks.append(error_reduction) 
plt.figure()
plt.grid(True)
plt.plot(Ks_list, Ks)
plt.title('Number of eigenfaces vs. Error reduction')
plt.xlabel('Eigenfaces')
plt.ylabel('Error reduction')
plt.show()